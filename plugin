local fpdh = game.Workspace.FallenPartsDestroyHeight
local plr = game.Players.LocalPlayer
local flingtype=true
local Camera=game.Workspace.CurrentCamera
local ContextActionService=game:GetService"ContextActionService";
local RunService=game:GetService"RunService"
local UserInputService=game:GetService'UserInputService'
local campart = Instance.new("Part");
campart.Anchored=true
campart.CanCollide=false
local INPUT_PRIORITY = Enum.ContextActionPriority.High.Value
campart.Transparency=1
RunService.PostSimulation:Connect(function()campart.CFrame=(flingtype and workspace.CurrentCamera.CFrame*CFrame.new(0,-2,-13)) or plr:GetMouse().Hit end)



function _isnetworkowner(Part)
	return Part.ReceiveAge == 0
end

function Align(Part1,part,cf,velocity)
	if not velocity then velocity = Vector3.new(20,20,20) end
    if typeof(part)=="CFrame" then part={CFrame=part} end
	local doit = true
	local con;con=RunService.PostSimulation:Connect(function()
		if not doit then return end
		if not Part1:IsDescendantOf(workspace) then con:Disconnect() return end
		if not _isnetworkowner(Part1) then return end
		Part1.Velocity = velocity
		Part1.CFrame=part.CFrame*cf
	end)
	return {Set=function(self,a) doit=a end,Disconnect=function() con:Disconnect() end,SetVelocity=function(self,a) velocity=a end}
end

Spring = {} do
	Spring.__index = Spring

	function Spring.new(freq, pos)
		local self = setmetatable({}, Spring)
		self.f = freq
		self.p = pos
		self.v = pos*0
		return self
	end

	function Spring:Update(dt, goal)
		local f = self.f*2*math.pi
		local p0 = self.p
		local v0 = self.v

		local offset = goal - p0
		local decay = math.exp(-f*dt)

		local p1 = goal + (v0*dt - offset*(f*dt + 1))*decay
		local v1 = (f*dt*(offset*f - v0) + v0)*decay

		self.p = p1
		self.v = v1

		return p1
	end

	function Spring:Reset(pos)
		self.p = pos
		self.v = pos*0
	end
end

local cameraPos = Vector3.new()
local cameraRot = Vector2.new()
cameraFov=70
local velSpring = Spring.new(5, Vector3.new())
local panSpring = Spring.new(5, Vector2.new())

Input = {} do

	keyboard = {
		W = 0,
		A = 0,
		S = 0,
		D = 0,
		E = 0,
		Q = 0,
		Up = 0,
		Down = 0,
		LeftShift = 0,
	}

	mouse = {
		Delta = Vector2.new(),
	}

	NAV_KEYBOARD_SPEED = Vector3.new(1, 1, 1)
	PAN_MOUSE_SPEED = Vector2.new(1, 1)*(math.pi/64)
	NAV_ADJ_SPEED = 0.75
	NAV_SHIFT_MUL = 0.25

	navSpeed = 1

	function Input.Vel(dt)
		navSpeed = math.clamp(navSpeed + dt*(keyboard.Up - keyboard.Down)*NAV_ADJ_SPEED, 0.01, 4)

		local kKeyboard = Vector3.new(
			keyboard.D - keyboard.A,
			keyboard.E - keyboard.Q,
			keyboard.S - keyboard.W
		)*NAV_KEYBOARD_SPEED

		local shift = UserInputService:IsKeyDown(Enum.KeyCode.LeftShift)

		return (kKeyboard)*(navSpeed*(shift and NAV_SHIFT_MUL or 1))
	end

	function Input.Pan(dt)
		local kMouse = mouse.Delta*PAN_MOUSE_SPEED
		mouse.Delta = Vector2.new()
		return kMouse
	end

	do
		function Keypress(action, state, input)
			keyboard[input.KeyCode.Name] = state == Enum.UserInputState.Begin and 1 or 0
			return Enum.ContextActionResult.Sink
		end

		function MousePan(action, state, input)
			local delta = input.Delta
			mouse.Delta = Vector2.new(-delta.y, -delta.x)
			return Enum.ContextActionResult.Sink
		end

		function Zero(t)
			for k, v in pairs(t) do
				t[k] = v*0
			end
		end

		function Input.StartCapture()
			ContextActionService:BindActionAtPriority("FreecamKeyboard",Keypress,false,INPUT_PRIORITY,
				Enum.KeyCode.W,
				Enum.KeyCode.A,
				Enum.KeyCode.S,
				Enum.KeyCode.D,
				Enum.KeyCode.E,
				Enum.KeyCode.Q,
				Enum.KeyCode.Up,
				Enum.KeyCode.Down
			)
			ContextActionService:BindActionAtPriority("FreecamMousePan",MousePan,false,INPUT_PRIORITY,Enum.UserInputType.MouseMovement)
		end

		function Input.StopCapture()
			navSpeed = 1
			Zero(keyboard)
			Zero(mouse)
			ContextActionService:UnbindAction("FreecamKeyboard")
			ContextActionService:UnbindAction("FreecamMousePan")
		end
	end
end

function GetFocusDistance(cameraFrame)
	local znear = 0.1
	local viewport = Camera.ViewportSize
	local projy = 2*math.tan(cameraFov/2)
	local projx = viewport.x/viewport.y*projy
	local fx = cameraFrame.rightVector
	local fy = cameraFrame.upVector
	local fz = cameraFrame.lookVector

	local minVect = Vector3.new()
	local minDist = 512

	for x = 0, 1, 0.5 do
		for y = 0, 1, 0.5 do
			local cx = (x - 0.5)*projx
			local cy = (y - 0.5)*projy
			local offset = fx*cx - fy*cy + fz
			local origin = cameraFrame.p + offset*znear
			local _, hit = workspace:FindPartOnRay(Ray.new(origin, offset.unit*minDist))
			local dist = (hit - origin).magnitude
			if minDist > dist then
				minDist = dist
				minVect = offset.unit
			end
		end
	end

	return fz:Dot(minVect)*minDist
end

local function StepFreecam(dt)
	local vel = velSpring:Update(dt, Input.Vel(dt))
	local pan = panSpring:Update(dt, Input.Pan(dt))

	local zoomFactor = math.sqrt(math.tan(math.rad(70/2))/math.tan(math.rad(cameraFov/2)))

	cameraRot = cameraRot + pan*Vector2.new(0.75, 1)*8*(dt/zoomFactor)
	cameraRot = Vector2.new(math.clamp(cameraRot.x, -math.rad(90), math.rad(90)), cameraRot.y%(2*math.pi))

	local cameraCFrame = CFrame.new(cameraPos)*CFrame.fromOrientation(cameraRot.x, cameraRot.y, 0)*CFrame.new(vel*Vector3.new(1, 1, 1)*64*dt)
	cameraPos = cameraCFrame.p

	Camera.CFrame = cameraCFrame
	Camera.Focus = cameraCFrame*CFrame.new(0, 0, -GetFocusDistance(cameraCFrame))
	Camera.FieldOfView = cameraFov
end

local PlayerState = {} do
	mouseBehavior = ""
	mouseIconEnabled = ""
	cameraType = ""
	cameraFocus = ""
	cameraCFrame = ""
	cameraFieldOfView = ""

	function PlayerState.Push()
		cameraFieldOfView = Camera.FieldOfView
		Camera.FieldOfView = 70

		cameraType = Camera.CameraType
		Camera.CameraType = Enum.CameraType.Custom

		cameraCFrame = Camera.CFrame
		cameraFocus = Camera.Focus

		mouseIconEnabled = UserInputService.MouseIconEnabled
		UserInputService.MouseIconEnabled = true

		mouseBehavior = UserInputService.MouseBehavior
		UserInputService.MouseBehavior = Enum.MouseBehavior.Default
	end

	function PlayerState.Pop()
		Camera.FieldOfView = 70

		Camera.CameraType = cameraType
		cameraType = nil

		Camera.CFrame = cameraCFrame
		cameraCFrame = nil

		Camera.Focus = cameraFocus
		cameraFocus = nil

		UserInputService.MouseIconEnabled = mouseIconEnabled
		mouseIconEnabled = nil

		UserInputService.MouseBehavior = mouseBehavior
		mouseBehavior = nil
	end
end

function StartFreecam(pos)
	if fcRunning then
		StopFreecam()
	end
	local cameraCFrame = Camera.CFrame
	if pos then
		cameraCFrame = pos
	end
	cameraRot = Vector2.new()
	cameraPos = cameraCFrame.p
	cameraFov = Camera.FieldOfView

	velSpring:Reset(Vector3.new())
	panSpring:Reset(Vector2.new())

	PlayerState.Push()
	RunService:BindToRenderStep("Freecam", Enum.RenderPriority.Camera.Value, StepFreecam)
	Input.StartCapture()
	fcRunning = true
end

function StopFreecam()
	if not fcRunning then return end
	Input.StopCapture()
	RunService:UnbindFromRenderStep("Freecam")
	PlayerState.Pop()
	workspace.Camera.FieldOfView = 70
	fcRunning = false
end
function Hatdrop(Character)
	Character:WaitForChild("Humanoid")
	task.wait(0.2)
    local AnimationInstance = Instance.new("Animation");AnimationInstance.AnimationId = "rbxassetid://35154961"
	workspace.FallenPartsDestroyHeight = 0/0
    local hrp = Character.HumanoidRootPart
    local startCF = hrp.CFrame
	local torso = Character:FindFirstChild("Torso") or Character:FindFirstChild("LowerTorso")
    local Track = Character.Humanoid.Animator:LoadAnimation(AnimationInstance)
    Track:Play()
    Track.TimePosition = 3.24
    Track:AdjustSpeed(0)
    local locks = {}
    for i,v in pairs(Character.Humanoid:GetAccessories()) do
        table.insert(locks,v.Changed:Connect(function(p)
            if p == "BackendAccoutrementState" then
                sethiddenproperty(v,"BackendAccoutrementState",0)
            end
        end))
        sethiddenproperty(v,"BackendAccoutrementState",2)
    end
    local c;c=game:GetService("RunService").PostSimulation:Connect(function()
        if(not Character:FindFirstChild("HumanoidRootPart"))then c:Disconnect()return;end
        
        hrp.Velocity = Vector3.new(0,0,25)
        hrp.RotVelocity = Vector3.new(0,0,0)
        hrp.CFrame = CFrame.new(startCF.X,fpdh+.25,startCF.Z) * (Character:FindFirstChild("Torso") and CFrame.Angles(math.rad(90),0,0) or CFrame.new())
    end)
    task.wait(.25)
	local alreadyfound = {}
	for i,v in pairs(Character.Humanoid:GetAccessories()) do
		local handle = v:FindFirstChild("Handle") if not handle then continue end
        local a = Align(handle,(campart),CFrame.new())
        task.delay(0.2,function()
            a:SetVelocity(Vector3.new(99999,99999,99999))
        end)
        local SelectionBox = Instance.new("SelectionBox")
		SelectionBox.Adornee = handle
		SelectionBox.LineThickness = 0.05
		SelectionBox.Parent = handle
	end
    Character.Humanoid:ChangeState(15)
	torso.AncestryChanged:Wait()
    for i,v in pairs(locks) do
        v:Disconnect()
    end
    for i,v in pairs(Character.Humanoid:GetAccessories()) do
        sethiddenproperty(v,"BackendAccoutrementState",4)
    end
end



--IY PLGUIN:

local Plugin = {
    ["PluginName"] = "IY Hatdrop",
    ["PluginDescription"] = "yeah yeah shut up skid",
    ["Commands"] = {
        ['hatdrop']={
            ["ListName"] = "hatdrop",
            ["Description"] = "thanks for stop hacking",
            ["Aliases"] = {''},
            ["Function"] = function(args,speaker)
                if not plr.Character then notify('hatdrop','you dont have a character')return end
                if not plr.Character:FindFirstChild("HumanoidRootPart") then notify('hatdrop','you\'re not loaded')return end

                workspace.Camera.CameraType = Enum.CameraType.Scriptable
                local AnimationInstance = Instance.new("Animation");AnimationInstance.AnimationId = "rbxassetid://35154961"
                workspace.FallenPartsDestroyHeight = 0/0
                local hrp = plr.Character.HumanoidRootPart
                local startCF = hrp.CFrame
                local torso = plr.Character:FindFirstChild("Torso") or plr.Character:FindFirstChild("LowerTorso")
                local Track = plr.Character.Humanoid.Animator:LoadAnimation(AnimationInstance)
                Track:Play()
                Track.TimePosition = 3.24
                Track:AdjustSpeed(0)
                local locks = {}
                for i,v in pairs(plr.Character.Humanoid:GetAccessories()) do
                    table.insert(locks,v.Changed:Connect(function(p)
                        if p == "BackendAccoutrementState" then
                            sethiddenproperty(v,"BackendAccoutrementState",0)
                        end
                    end))
                    sethiddenproperty(v,"BackendAccoutrementState",2)
                end
                local c;c=game:GetService("RunService").PostSimulation:Connect(function()
                    if(not plr.Character:FindFirstChild("HumanoidRootPart"))then c:Disconnect()return;end
                    
                    hrp.Velocity = Vector3.new(0,0,25)
                    hrp.RotVelocity = Vector3.new(0,0,0)
                    hrp.CFrame = CFrame.new(startCF.X,fpdh+.25,startCF.Z) * (plr.Character:FindFirstChild("Torso") and CFrame.Angles(math.rad(90),0,0) or CFrame.new())
                end)
                task.wait(.25)
                for i,v in pairs(plr.Character.Humanoid:GetAccessories()) do
                    local handle = v:FindFirstChild("Handle") if not handle then continue end
                    local a = Align(handle,startCF*CFrame.new(0,i+handle.Size.Y,-5),CFrame.new(),Vector3.zero)
                    task.delay(0.8,function() a:Disconnect() end)
                end
                plr.Character.Humanoid:ChangeState(15)
                torso.AncestryChanged:Wait()
                for i,v in pairs(locks) do
                    v:Disconnect()
                end
                for i,v in pairs(plr.Character.Humanoid:GetAccessories()) do
                    sethiddenproperty(v,"BackendAccoutrementState",4)
                end
                plr.CharacterAdded:Wait()
                workspace.Camera.CameraType = Enum.CameraType.Custom
            end
        },
        ["hatfling"] = {
            ["ListName"] = "hatfling/hf [camera or mouse]",
            ["Description"] = "bruh stupid hacker",
            ["Aliases"] = {'hf'},
            ["Function"] = function(args,speaker)
                StartFreecam()
                notify('hatdrop','hatfling on')
                Hatdrop(plr.Character)
                STUPIDDIOTRETARDDUMBAUTISTICIFLINGERHACKEREXPLOPITERKYSBRO = plr.CharacterAdded:Connect(Hatdrop)
            end
        },
        ['stophatfling']={
            ["ListName"] = "stophatfling/unhatfling",
            ["Description"] = "thanks for stop hacking",
            ["Aliases"] = {'unhatfling'},
            ["Function"] = function(args,speaker)
                if STUPIDDIOTRETARDDUMBAUTISTICIFLINGERHACKEREXPLOPITERKYSBRO then STUPIDDIOTRETARDDUMBAUTISTICIFLINGERHACKEREXPLOPITERKYSBRO:Disconnect() end
                notify('hatdrop','hatfling off, wait for respawn')
                StopFreecam()
            end
        }
    }
}

return Plugin
